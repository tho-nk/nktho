[{"content":"1. Architect The trading exchange is designed with a modular architecture that enhances its performance and scalability.\n2. Server The server serves as the backbone of the trading exchange, utilizing the UDP (User Datagram Protocol) for communication. This protocol is selected for its low-latency characteristics, essential in trading environments where every millisecond matters. However, it\u0026rsquo;s important to note that UDP can lead to packet loss, which may not be ideal for trading. As such, a future transition to TCP (Transmission Control Protocol) is planned to ensure more reliable communication, providing guaranteed delivery of messages. The server efficiently processes incoming client requests and dispatches them to the matching engine.\nAsynchronous Handling: Implemented using Boost.Asio, the server can handle multiple requests concurrently without blocking, allowing it to serve numerous clients simultaneously while maintaining high responsiveness. 2.1 Matching Engine The matching engine is the core component responsible for executing trades by matching buy and sell orders based on specific criteria. Its architecture includes several key features:\nMulti-Orderbook Support: The engine supports multiple orderbooks, each corresponding to a different trading symbol (e.g., stock, commodity).\nAtPriceOrderMap: This structure is designed to maintain orders with the same price. Each price level contains an AtPriceOrder which groups orders that share the same price point. Orders are prioritized based on their submission time, ensuring fairness in execution.\nHashtable Utilization: By using a hashtable (implemented with std::array), the matching engine achieves constant-time complexity for lookups, allowing for quick access to active orders.\nTop of Book (TOB): The engine maintains a Top of Book (TOB) for both buy and sell sides, facilitating immediate access to the best available prices.\nBuy Side TOB: Represents the highest buy price currently available. The next AtPriceOrder in the sequence is the next highest order, ensuring that the market is transparent for buyers.\nSell Side TOB: Represents the lowest sell price, with the subsequent order being the next smallest price. This mechanism promotes competitive pricing in the market.\nOrder Management: The OrderManager component is critical for managing the lifecycle of orders. It handles:\nOrder Creation: Facilitates the submission of new orders into the orderbook. Order Expiry: Responsible for removing orders that are no longer valid (e.g., due to time constraints or market conditions). 2.2 FIFO Queue To enable efficient communication between the server and the matching engine, a thread-safe MPMC (Multi-Producers, Multi-Consumers) queue is utilized. This design allows multiple threads to produce and consume messages concurrently without risking data corruption.\nOutput Streaming: Standard Output (Stdout): Used for streaming results from the matching engine, ensuring that all output is managed in a thread-safe manner to prevent data races. Standard Log (Stdlog): Employed for logging performance metrics, allowing for detailed monitoring of system performance. Example log messages include: Perf|OrderBook|Add|Execution|111: Indicates that an order was added, with an execution time of 111 milliseconds. Perf|OrderBook|Cancel|Execution|50: Indicates that an order was canceled, with an execution time of 50 milliseconds. 3. Improvements To enhance the functionality and performance of the trading exchange, several improvements are planned:\nProtocol Support: Develop an interface for the server to support additional communication protocols, such as TCP/IP. This would provide flexibility for clients to connect using various network protocols, improving usability.\nFIX Protocol Implementation: Integrate the FIX (Financial Information eXchange) protocol, a standardized messaging protocol for the real-time exchange of securities transactions. This would enhance interoperability with other trading systems and brokers.\nLock-Free Queue Development: Create a lock-free queue to minimize contention between threads. This would enhance performance in high-frequency trading scenarios where order flow can be extremely high.\nPerformance Optimization: Conduct performance profiling and optimization to identify bottlenecks within the system, ensuring that the exchange can handle increased loads efficiently.\nObject Pool Implementation: Introduce an object pool to manage the allocation and deallocation of objects. This technique reduces the overhead of dynamic memory allocations, leading to improved performance and reduced latency.\nBy focusing on these enhancements, the trading exchange aims to deliver a robust, scalable, and high-performance platform that meets the demands of modern financial markets.\n","date":"2024-06-24T00:00:00Z","image":"https://www.nktho.fr/p/trading_exchange/trading_exchange_hu9146400831550434613.webp","permalink":"https://www.nktho.fr/p/trading_exchange/","title":"Stock Exchange"},{"content":" 1. Overview This parser is designed to support the PGN (Portable Game Notation) format, commonly used for recording chess games. The parser reads the movetext, which is written in Standard Algebraic Notation (SAN), and processes each move to update the internal chessboard state. It fully supports the PGN specification, ensuring compatibility with most chess applications.\nAt the end of the game, the board state is output in an 8x8 grid format, as shown below:\nInput\n1 1. e4 e6 2. e5 f6 3. exf6 gxf6 4. Ke2 h6 5. Ke3 h5 6. Ke4 e5 7. Nh3 d6 8. Ng5 Be6 9. Nf3 Bh3 10. Nc3 Bxg2 11. Na4 b6 12. Nc5 b5 13. Nd3 b4 14. Nxe5 b3 1/2-1/2 Output\n1 2 3 4 5 6 7 8 bR|bN| |bQ|bK|bB|bN|bR bP| |bP| | | | | | | |bP| |bP| | | | | |wN| | |bP | | | |wK| | | |bP| | | |wN| | wP|wP|wP|wP| |wP|bB|wP wR| |wB|wQ| |wB| |wR Project Requirements\nCMake 3.22 GCC 12.1 and C++20 standard Ubuntu 23.10 or the Docker image iainttho/ubuntu:23.10.02 based on Ubuntu 23.10. 2. Architecture This project uses a modern C++ design with CRTP (Curiously Recurring Template Pattern) and std::variant to represent pieces, providing a flexible and efficient approach to handle polymorphism without traditional inheritance or virtual function tables (vtables). The code achieves runtime polymorphism using std::visit for handling different types of pieces.\n2.1 BasePiece Class The BasePiece class provides the foundation for all chess pieces, using CRTP to allow specific behavior for each piece type. This avoids the overhead of virtual function calls while keeping the code type-safe and efficient.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template \u0026lt;typename ConcretePiece\u0026gt; class BasePiece { public: ... // Potential improvement with `this ConcretePiece\u0026amp;\u0026amp; self` ConcretePiece \u0026amp;self() { return *static_cast\u0026lt;ConcretePiece *\u0026gt;(this); } ConcretePiece const \u0026amp;self() const { return *static_cast\u0026lt;ConcretePiece const *\u0026gt;(this); } bool IsValidBasicMove(...) const { return self().IsValidBasicMove_(...); } ... protected: friend ConcretePiece; BasePiece(...) {} ... }; 2.2 Concrete Piece Classes Each piece type (like Bishop, Knight, etc.) inherits from BasePiece and implements its specific movement logic.\n1 2 3 4 5 6 7 8 9 class Bishop : public BasePiece\u0026lt;Bishop\u0026gt; { public: Bishop(...) : BasePiece(...) {} ... private: friend class BasePiece\u0026lt;Bishop\u0026gt;; bool IsValidBasicMove_(...) const; ... }; 2.3 Piece Representation Using std::variant The chessboard contains pieces represented as std::variant, allowing it to store different types of pieces in the same container while retaining type safety.\n1 2 3 using Piece = std::variant\u0026lt;EmptyPiece, Bishop, King, Knight, Pawn, Queen, Rook\u0026gt;; using Pieces = std::vector\u0026lt;std::vector\u0026lt;Piece\u0026gt;\u0026gt;; using PiecesReference = std::vector\u0026lt;std::reference_wrapper\u0026lt;const Piece\u0026gt;\u0026gt;; 2.4 Square Class The Square class is responsible for processing moves and managing the state of the pieces. It validates moves, checks whether the king is in check, and applies the necessary updates to the board.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Square { public: ... PiecesReference GetPieceOfTypeAndColor(const PieceType \u0026amp;pieceType, const Color \u0026amp;color, ...) const { PiecesReference subPieces; ... return subPieces; } void ProcessBasicMove(...); private: ... Pieces pieces_; private: void ValidateMove(...); bool VerifyIfKingBeingCheck(...); }; In Square::ProcessBasicMove, std::visit is used to handle pieces of different types polymorphically:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Square::ProcessBasicMove(...) { ... // Get pieces of a specific type (Pawn) and color (White) const PiecesReference \u0026amp;subPieces = GetPieceOfTypeAndColor(PieceType::Pawn, Color::White, ...); bool isValid = false; // Iterate through the pieces to check if any can perform a valid basic move for (auto \u0026amp;it : subPieces) { std::visit( [\u0026amp;](auto \u0026amp;\u0026amp;piece) { isValid = piece.IsValidBasicMove(); ValidateMove(...); }, it.get()); if (isValid) break; } ... } 2.5 Polymorphism without vtables Utilizing std::visit for Type Handling:\nstd::visit is a C++17 utility that enables the application of a callable, such as a lambda function, to the value stored in a std::variant. This feature is especially beneficial for managing the diverse types of pieces that may be contained within the variant, facilitating a form of polymorphism. Collection of Variants:\nThe subPieces variable is designed as a collection of std::variant, which allows it to store various types of chess pieces. This architecture supports the retention of type safety while accommodating multiple types within a single collection. Method Invocation Without Type Knowledge:\nWith std::visit, we can call methods on the pieces stored in the variant without prior knowledge of their specific types at compile time. The lambda function provided to std::visit executes with the actual type contained in the variant, streamlining operations on the pieces. Achieving Polymorphic Behavior:\nThe combination of std::visit and std::variant enables the implementation of polymorphic behavior without relying on traditional inheritance. This design choice ensures that multiple piece types can be managed in a type-safe manner, enhancing the flexibility and robustness of the system. 3. Pros and Cons 3.1 Pros Type Safety: Guarantees type-safe operations with std::variant. Polymorphism: Achieves runtime polymorphism without virtual function overhead. Performance: Avoids pointer indirection and the cost of vtables, making the code more efficient. 3.2 Cons Compile-time Knowledge: All possible types must be known at compile time. Error Handling: Handling unexpected types or errors in std::variant can be complex. Debugging: Debugging std::variant interactions can be challenging. Memory Overhead: Variants may consume more memory if piece sizes differ significantly, leading to potential inefficiencies. 4. Improvements Add iterative move parsing and game state tracking. Support backward and forward navigation through the game\u0026rsquo;s moves. Improve the piece swap mechanism for better handling of complex moves. For more insights, refer to the following resources:\nA Journey Into Non-Virtual Polymorphism in C++ - Rudyard Merriam - CppCon 2023 C++ : Polymorphic inheritance without vtable ","date":"2024-06-22T00:00:00Z","image":"https://www.nktho.fr/p/pgn_parser/pieces_hu7257183300916291865.webp","permalink":"https://www.nktho.fr/p/pgn_parser/","title":"PGN Parser"}]