[{"content":"Table of Contents\nOverview Architecture Improvement 1. Overview This parser supports the PGN format based on Portable Game Notation. The movetext is based on SAN (Standard Algebraic Notation). Disambiguation is supported by checking VerifyIfKingBeingCheck before accepting a move.\nIt requires:\nCMake 3.22 GCC 12.1 and C++20 standard Ubuntu 23.10 or the Docker image iainttho/ubuntu:23.10.02 based on Ubuntu 23.10. The state of the board at the end of the game, in the form of an 8x8 grid:\n1 2 3 4 5 6 7 8 bR|bN|bB|bQ|bK|bB|bN|bR bP|bP|bP|bP|bP|bP|bP|bP | | | | | | | | | | | | | | | | | | | | | | | | | | | | wP|wP|wP|wP|wP|wP|wP|wP wR|wN|wB|wQ|wK|wB|wN|wR Input 1 1. e4 e6 2. e5 f6 3. exf6 gxf6 4. Ke2 h6 5. Ke3 h5 6. Ke4 e5 7. Nh3 d6 8. Ng5 Be6 9. Nf3 Bh3 10. Nc3 Bxg2 11. Na4 b6 12. Nc5 b5 13. Nd3 b4 14. Nxe5 b3 1/2-1/2 Output 1 2 3 4 5 6 7 8 bR|bN| |bQ|bK|bB|bN|bR bP| |bP| | | | | | | |bP| |bP| | | | | |wN| | |bP | | | |wK| | | |bP| | | |wN| | wP|wP|wP|wP| |wP|bB|wP wR| |wB|wQ| |wB| |wR 2. Architecture In this project, I\u0026rsquo;ve implemented a new approach using std::variant to represent the pieces within the square. This leverages the CRTP (Curiously Recurring Template Pattern) to achieve a flexible and efficient solution. Polymorphism is implemented using std::visit, providing runtime polymorphism without relying on virtual functions and vtables.\nBasePiece Class The piece type is represented using the BasePiece template class:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 template \u0026lt;typename ConcretePiece\u0026gt; class BasePiece { public: ... // Provides access to the derived class, potential improvement with `this ConcretePiece\u0026amp;\u0026amp; self` ConcretePiece \u0026amp;self() { return *static_cast\u0026lt;ConcretePiece *\u0026gt;(this); } ConcretePiece const \u0026amp;self() const { return *static_cast\u0026lt;ConcretePiece const *\u0026gt;(this); } ... // Validates basic moves bool IsValidBasicMove(...) const { return self().IsValidBasicMove_(...); } // Validates attack moves bool IsValidAttackMove(...) const { return self().IsValidAttackMove_(...); } ... protected: friend ConcretePiece; BasePiece(...) {} }; Derived Piece Classes Each type of piece implements its specific characteristics:\n1 2 3 4 5 6 7 8 9 10 class Bishop : public BasePiece\u0026lt;Bishop\u0026gt; { public: Bishop(...) : BasePiece(...) {} Bishop() = default; private: friend class BasePiece\u0026lt;Bishop\u0026gt;; bool IsValidBasicMove_(...) const; bool IsValidAttackMove_(...) const; }; Piece Variants Pieces are represented using std::variant:\n1 2 3 using Piece = std::variant\u0026lt;EmptyPiece, Bishop, King, Knight, Pawn, Queen, Rook\u0026gt;; using Pieces = std::vector\u0026lt;std::vector\u0026lt;Piece\u0026gt;\u0026gt;; using PiecesReference = std::vector\u0026lt;std::reference_wrapper\u0026lt;const Piece\u0026gt;\u0026gt;; Move Classes There are 5 move types defined, with potential improvements using virtual inheritance for AttackPromotionMove:\n1 2 3 4 5 6 class Move {}; class AttackMove : public Move {}; class AttackPromotionMove : public Move {}; class BasicMove : public Move {}; class CastlingMove : public Move {}; class PromotionMove : public Move {}; Round Class Each round consists of a white and black move, and a pointer to a square:\n1 2 3 4 5 6 7 8 9 class Round { public: ... private: std::unique_ptr\u0026lt;Move\u0026gt; whiteMove_; std::unique_ptr\u0026lt;Move\u0026gt; blackMove_; Square *square_; }; using Rounds = std::vector\u0026lt;Round\u0026gt;; Square Class The Square class processes moves and manages the state of the pieces:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Square { public: ... // Process BasicMove void ProcessBasicMove(...); void MovePiece(...); // Process AttackMove void ProcessAttackMove(...); void AttackPiece(...); // Process PromotionMove void ProcessPromotionMove(...); // Process AttackPromotionMove Pawn only void ProcessAttackPromotionMove(...); private: ... Pieces pieces_; Rounds rounds_; private: void ValidateMove(...); bool VerifyIfKingBeingCheck(...); }; For more insights, refer to the following resources:\nA Journey Into Non-Virtual Polymorphism in C++ - Rudyard Merriam - CppCon 2023 C++ : Polymorphic inheritance without vtable 3. Improvement Add Iterative mode Support Forward-Backward interaction Overload piece swap ","date":"2024-06-22T00:00:00Z","image":"https://www.nktho.fr/p/programmation/eifel_hu5cc6d93db45cbbd6ae4d62acca4e5f7e_165761_120x120_fill_q75_box_smart1.jpeg","permalink":"https://www.nktho.fr/p/programmation/","title":"PGN Parser"}]