[{"content":"Table of Contents\nOverview Architecture Pros and Cons Improvement 1. Overview This parser supports the PGN format based on Portable Game Notation. The movetext is based on SAN (Standard Algebraic Notation). Disambiguation is supported by checking if the king is being checked before accepting a move.\nIt requires:\nCMake 3.22 GCC 12.1 and C++20 standard Ubuntu 23.10 or the Docker image iainttho/ubuntu:23.10.02 based on Ubuntu 23.10. The state of the board at the end of the game, in the form of an 8x8 grid:\n1 2 3 4 5 6 7 8 bR|bN|bB|bQ|bK|bB|bN|bR bP|bP|bP|bP|bP|bP|bP|bP | | | | | | | | | | | | | | | | | | | | | | | | | | | | wP|wP|wP|wP|wP|wP|wP|wP wR|wN|wB|wQ|wK|wB|wN|wR Input 1 1. e4 e6 2. e5 f6 3. exf6 gxf6 4. Ke2 h6 5. Ke3 h5 6. Ke4 e5 7. Nh3 d6 8. Ng5 Be6 9. Nf3 Bh3 10. Nc3 Bxg2 11. Na4 b6 12. Nc5 b5 13. Nd3 b4 14. Nxe5 b3 1/2-1/2 Output 1 2 3 4 5 6 7 8 bR|bN| |bQ|bK|bB|bN|bR bP| |bP| | | | | | | |bP| |bP| | | | | |wN| | |bP | | | |wK| | | |bP| | | |wN| | wP|wP|wP|wP| |wP|bB|wP wR| |wB|wQ| |wB| |wR 2. Architecture In this project, I\u0026rsquo;ve implemented a new approach using std::variant to represent the pieces within the square. This leverages the CRTP (Curiously Recurring Template Pattern) to achieve a flexible and efficient solution. Polymorphism is implemented using std::visit, providing runtime polymorphism without relying on virtual functions and vtables.\nBasePiece Class The piece type is represented using the BasePiece template class, leveraging CRTP for flexible and efficient code structuring.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template \u0026lt;typename ConcretePiece\u0026gt; class BasePiece { public: ... // Provides access to the derived class, potential improvement with `this ConcretePiece\u0026amp;\u0026amp; self` ConcretePiece \u0026amp;self() { return *static_cast\u0026lt;ConcretePiece *\u0026gt;(this); } ConcretePiece const \u0026amp;self() const { return *static_cast\u0026lt;ConcretePiece const *\u0026gt;(this); } // Validates basic moves bool IsValidBasicMove(...) const { return self().IsValidBasicMove_(...); } ... protected: friend ConcretePiece; BasePiece(...) {} ... }; Derived Piece Classes Each type of piece implements its specific characteristics:\n1 2 3 4 5 6 7 8 9 class Bishop : public BasePiece\u0026lt;Bishop\u0026gt; { public: Bishop(...) : BasePiece(...) {} ... private: friend class BasePiece\u0026lt;Bishop\u0026gt;; bool IsValidBasicMove_(...) const; ... }; Piece Variants Pieces are represented using std::variant:\n1 2 3 using Piece = std::variant\u0026lt;EmptyPiece, Bishop, King, Knight, Pawn, Queen, Rook\u0026gt;; using Pieces = std::vector\u0026lt;std::vector\u0026lt;Piece\u0026gt;\u0026gt;; using PiecesReference = std::vector\u0026lt;std::reference_wrapper\u0026lt;const Piece\u0026gt;\u0026gt;; Square Class The Square class processes moves and manages the state of the pieces:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Square { public: ... PiecesReference GetPieceOfTypeAndColor(const PieceType \u0026amp;pieceType, const Color \u0026amp;color, ...) const { PiecesReference subPieces; ... return subPieces; } // Process BasicMove void ProcessBasicMove(...); private: ... Pieces pieces_; Rounds rounds_; private: // A move is valid if King won\u0026#39;t be checked void ValidateMove(...); bool VerifyIfKingBeingCheck(...); }; Square::ProcessBasicMove(...) { ... // Get pieces of a specific type (Pawn) and color (White) const PiecesReference \u0026amp;subPieces = GetPieceOfTypeAndColor(PieceType::Pawn, Color::White, ...); bool isValid = false; // Iterate through the pieces to check if any can perform a valid basic move for (auto \u0026amp;it : subPieces) { std::visit( [\u0026amp;](auto \u0026amp;\u0026amp;piece) { isValid = piece.IsValidBasicMove(); ValidateMove(...); }, it.get()); if (isValid) break; } ... } Explanation of std::visit and std::variant for Polymorphism:\nstd::visit is used to handle the different possible types of pieces in a polymorphic manner:\nstd::visit is a utility function in C++17 that allows you to apply a callable (like a lambda function) to the value contained within a std::variant. This is particularly useful for handling different types that might be stored in the variant, providing a form of polymorphism. subPieces is a collection of std::variant, which can hold different types of pieces. This design allows for storing multiple types in a single collection while retaining type safety. By using std::visit, we can invoke methods on the pieces contained in the variant without needing to know the specific type of each piece at compile time. The lambda function inside std::visit will be called with the actual type held by the variant. Using std::visit in conjunction with std::variant allows you to achieve polymorphic behavior without traditional inheritance, enabling you to handle multiple piece types in a type-safe manner.\n3. Pros and Cons Pros Type Safety: Ensures type-safe operations within variant. Polymorphic Behavior: Enables runtime polymorphism without vtables. Efficiency: Eliminates overhead from virtual function calls and pointer indirection typically associated with traditional inheritance models. Flexibility: Supports adding new types without interface changes. Cons Compile-Time Knowledge: Requires knowing all variant types at compile time. Error Handling Complexity: Handling unexpected types can be complex. Debugging Complexity: Debugging interactions between variants and lambda functions can be intricate. Memory Usage: Variants may consume more memory if objects stored have significantly different sizes, leading to potential memory fragmentation and inefficiency. 4. Improvement Add Iterative mode Support Forward-Backward interaction Overload piece swap For more insights, refer to the following resources:\nA Journey Into Non-Virtual Polymorphism in C++ - Rudyard Merriam - CppCon 2023 C++ : Polymorphic inheritance without vtable ","date":"2024-06-22T00:00:00Z","image":"https://www.nktho.fr/p/programmation/eifel_hu5cc6d93db45cbbd6ae4d62acca4e5f7e_165761_120x120_fill_q75_box_smart1.jpeg","permalink":"https://www.nktho.fr/p/programmation/","title":"PGN Parser"}]